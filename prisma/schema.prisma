// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enhanced enums for banking standards
enum UserType {
  APP_USER
  VPA_ONLY
}

enum KycStatus {
  NOT_STARTED
  PENDING
  VERIFIED
  REJECTED
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BLOCKED
}

enum PaymentType {
  P2P
  P2M
  ESCROW
}

enum TransferType {
  UPI
  RTGS
  IMPS
  NEFT
  NACH
}

enum CollectionStatus {
  INITIATED
  PROCESSING
  COMPLETED
  FAILED
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum RefundStatus {
  INITIATED
  PROCESSING
  COMPLETED
  FAILED
}

enum AuditAction {
  CREATED
  UPDATED
  STATUS_CHANGED
  CANCELLED
  REFUNDED
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model User {
  id                    String    @id @default(cuid())
  phoneE164             String    @unique @map("phone_e164")
  name                  String?
  avatarUrl             String?   @map("avatar_url")
  isOnboardingComplete  Boolean   @default(false) @map("is_onboarding_complete")
  onboardingCompletedAt DateTime? @map("onboarding_completed_at")
  monthlySalary         Decimal?  @map("monthly_salary") @db.Decimal(12, 2)
  currency              String    @default("INR")
  timeZone              String?   @map("time_zone")
  language              String    @default("en")
  notificationsEnabled  Boolean   @default(true) @map("notifications_enabled")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  // Enhanced banking fields
  userType              UserType    @default(APP_USER) @map("user_type")
  kycStatus             KycStatus   @default(NOT_STARTED) @map("kyc_status")
  userStatus            UserStatus  @default(ACTIVE) @map("user_status")
  primaryVpa            String?     @map("primary_vpa")
  extractedPhone        String?     @map("extracted_phone")
  riskScore             Decimal?    @default(0.0) @db.Decimal(3, 2) @map("risk_score")
  lastActivityAt        DateTime?   @map("last_activity_at")
  deviceFingerprint     String?     @map("device_fingerprint")
  blockedReason         String?     @map("blocked_reason")
  blockedAt             DateTime?   @map("blocked_at")
  blockedBy             String?     @map("blocked_by")

  // Relations
  categories           Category[]
  paymentIntents       PaymentIntent[]
  userSettings         UserSettings?
  spendingCaps         SpendingCap[]

  // Banking relations
  vpaIds               VpaRegistry[]
  sentPayments         BankingPayment[] @relation("PaymentSender")
  receivedPayments     BankingPayment[] @relation("PaymentReceiver")

  @@map("users")
}

model UserSettings {
  id                   String   @id @default(cuid())
  userId               String   @unique @map("user_id")
  themePreference      String   @default("system") // "light", "dark", "system"
  biometricEnabled     Boolean  @default(false) @map("biometric_enabled")
  transactionAlerts    Boolean  @default(true) @map("transaction_alerts")
  budgetAlerts         Boolean  @default(true) @map("budget_alerts")
  monthlyReports       Boolean  @default(true) @map("monthly_reports")
  marketingEmails      Boolean  @default(false) @map("marketing_emails")
  autoTagging          Boolean  @default(true) @map("auto_tagging")
  spendingInsights     Boolean  @default(true) @map("spending_insights")
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model Category {
  id                String    @id @default(cuid())
  userId            String    @map("user_id")
  name              String
  color             String
  capAmount         Decimal?  @map("cap_amount") @db.Decimal(10, 2)
  softBlock         Boolean   @default(false) @map("soft_block")
  nearThresholdPct  Int       @default(80) @map("near_threshold_pct")
  periodStart       DateTime? @map("period_start")
  canonicalCategoryId String? @map("canonical_category_id")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  user User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  canonicalCategory CategoryCatalog? @relation(fields: [canonicalCategoryId], references: [id])
  tags Tag[]
  spendingCaps SpendingCap[]

  @@unique([userId, name])
  @@index([canonicalCategoryId])
  @@map("categories")
}

// Global Category Taxonomy
model CategoryCatalog {
  id        String   @id @default(cuid())
  name      String   @unique
  slug      String   @unique
  aliases   Json?    // string[] for alternate names
  parentName String? @map("parent_name")
  color     String   @default("#C7ECEE") // Default color
  defaultCapAmount Decimal? @map("default_cap_amount") @db.Decimal(10, 2)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  categories      Category[]
  vpaRegistries   VpaRegistry[]
  merchantCatalog MerchantCatalog[]
  communityLabels CommunityLabel[]

  @@map("category_catalogs")
}

// Normalized Merchant Database
model MerchantCatalog {
  id               String   @id @default(cuid())
  name             String
  normalizedName   String   @unique @map("normalized_name")
  subcategory      String?
  aliases          Json?    // string[] for alternate names
  categoryCatalogId String  @map("category_catalog_id")
  confidence       Float    @default(0.8) // Confidence in categorization
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  // Relations
  categoryCatalog CategoryCatalog @relation(fields: [categoryCatalogId], references: [id])

  @@index([categoryCatalogId])
  @@index([normalizedName])
  @@map("merchant_catalogs")
}

// Community-Driven Category Labels
model CommunityLabel {
  id                String   @id @default(cuid())
  key               String   @unique // hash of normalized merchant+vpa
  vpaAddress        String?  @map("vpa_address") // Phase 3: Direct VPA address for community voting
  categoryCatalogId String   @map("category_catalog_id")
  confidence        Float    @default(0.5)
  votes             Int      @default(1)
  source            String   @default("AUTO") // AUTO | MANUAL - Phase 3: Track vote source
  lastSeenAt        DateTime @default(now()) @map("last_seen_at")
  lastUpdated       DateTime? @map("last_updated") // Phase 3: Track when updated
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relations
  categoryCatalog CategoryCatalog @relation(fields: [categoryCatalogId], references: [id])

  @@index([categoryCatalogId])
  @@index([key])
  @@index([vpaAddress])
  @@index([lastSeenAt])
  @@map("community_labels")
}

model SpendingCap {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  categoryId   String   @map("category_id")
  categoryName String   @map("category_name")
  color        String
  description  String?
  dailyLimit   Decimal  @map("daily_limit") @db.Decimal(10, 2)
  weeklyLimit  Decimal  @map("weekly_limit") @db.Decimal(10, 2)
  monthlyLimit Decimal  @map("monthly_limit") @db.Decimal(10, 2)
  isEnabled    Boolean  @default(true) @map("is_enabled")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([userId, categoryId])
  @@map("spending_caps")
}

enum PaymentStatus {
  CREATED
  SUCCESS
  FAILED
  PENDING
  MANUAL
}

enum Platform {
  ANDROID
  IOS
}

model PaymentIntent {
  id          String        @id @default(cuid())
  userId      String        @map("user_id")
  trRef       String        @unique @map("tr_ref") // Transaction reference
  vpa         String        // Virtual Payment Address
  payeeName   String?       @map("payee_name")
  amount      Decimal       @db.Decimal(10, 2)
  currency    String        @default("INR")
  status      PaymentStatus @default(CREATED)
  platform    Platform?
  entrypoint  String? // Where the payment was initiated from
  noteLong    String?       @map("note_long")
  initiatedAt DateTime      @default(now()) @map("initiated_at")
  completedAt DateTime?     @map("completed_at")
  upiTxnRef   String?       @map("upi_txn_ref") // UPI transaction reference from PSP

  // Banking system integration
  bankingPaymentId String?        @unique @map("banking_payment_id") // Link to banking compliance record
  transferType     TransferType   @default(UPI) @map("transfer_type") // Type of transfer (UPI, RTGS, etc.)

  // Enhanced metadata
  categoryOverride String?  @map("category_override") // User-selected category for this transaction
  isReceiptGenerated Boolean @default(false) @map("is_receipt_generated")
  receiptViewed     Boolean @default(false) @map("receipt_viewed")

  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  // Relations
  user              User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankingPayment    BankingPayment?        @relation(fields: [bankingPaymentId], references: [id])
  tags              Tag[]
  memos             Memo[]
  receipt           PaymentReceipt?
  analytics         TransactionAnalytics?

  @@map("payment_intents")
}

enum TagSource {
  AUTO
  MANUAL
}

model Tag {
  id              String        @id @default(cuid())
  paymentIntentId String        @map("payment_intent_id")
  categoryId      String        @map("category_id")
  tagText         String        @map("tag_text")
  source          TagSource     @default(AUTO)
  createdAt       DateTime      @default(now()) @map("created_at")

  // Relations
  paymentIntent PaymentIntent @relation(fields: [paymentIntentId], references: [id], onDelete: Cascade)
  category      Category      @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@map("tags")
}

enum MemoType {
  TEXT
  VOICE
}

model Memo {
  id              String        @id @default(cuid())
  paymentIntentId String        @map("payment_intent_id")
  type            MemoType
  textEncrypted   String?       @map("text_encrypted") // AES-GCM encrypted
  transcript      String?       // Voice-to-text transcript
  transcriptConfidence Float?   @map("transcript_confidence") // AI transcription confidence score
  lang            String?       // Language code (e.g., "en", "hi")
  durationMs      Int?          @map("duration_ms") // Duration for voice memos
  isProcessed     Boolean       @default(false) @map("is_processed") // Whether transcription is complete
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  // Relations
  paymentIntent PaymentIntent  @relation(fields: [paymentIntentId], references: [id], onDelete: Cascade)
  attachments   Attachment[]

  @@map("memos")
}

model Attachment {
  id        String   @id @default(cuid())
  memoId    String   @map("memo_id")
  mediaType String   @map("media_type") // MIME type
  objectKey String   @map("object_key") // S3 object key
  fileName  String?  @map("file_name") // Original file name
  durationMs Int?    @map("duration_ms") // For audio files
  sizeBytes  Int      @map("size_bytes")
  checksum   String   // SHA-256 checksum
  uploadUrl  String?  @map("upload_url") // Presigned upload URL (temporary)
  downloadUrl String? @map("download_url") // Presigned download URL (temporary)
  isUploaded Boolean  @default(false) @map("is_uploaded") // Whether file is uploaded to S3
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Relations
  memo Memo @relation(fields: [memoId], references: [id], onDelete: Cascade)

  @@map("attachments")
}

// Enhanced Payment Receipt model for detailed transaction records
model PaymentReceipt {
  id                   String        @id @default(cuid())
  paymentIntentId      String        @unique @map("payment_intent_id")
  receiptNumber        String        @unique @map("receipt_number") // Sequential receipt number

  // Collection Details (Money coming in from user)
  collectionId         String?       @map("collection_id")
  collectionAmount     Decimal?      @db.Decimal(10, 2) @map("collection_amount")
  collectionFee        Decimal?      @db.Decimal(10, 2) @map("collection_fee")
  collectionStatus     String?       @map("collection_status")
  collectionReference  String?       @map("collection_reference")
  collectionCompletedAt DateTime?    @map("collection_completed_at")

  // Payout Details (Money going out to recipient)
  payoutId            String?        @map("payout_id")
  payoutAmount        Decimal?       @db.Decimal(10, 2) @map("payout_amount")
  payoutFee           Decimal?       @db.Decimal(10, 2) @map("payout_fee")
  payoutStatus        String?        @map("payout_status")
  payoutReference     String?        @map("payout_reference")
  payoutCompletedAt   DateTime?      @map("payout_completed_at")

  // Totals and Summary
  totalAmount         Decimal        @db.Decimal(10, 2) @map("total_amount")
  totalFees           Decimal        @db.Decimal(10, 2) @map("total_fees")
  netAmount           Decimal        @db.Decimal(10, 2) @map("net_amount")

  // Receipt Metadata
  issuedAt            DateTime       @default(now()) @map("issued_at")
  createdAt           DateTime       @default(now()) @map("created_at")
  updatedAt           DateTime       @updatedAt @map("updated_at")

  // Relations
  paymentIntent PaymentIntent @relation(fields: [paymentIntentId], references: [id], onDelete: Cascade)

  @@map("payment_receipts")
}

// Transaction Analytics for better insights
model TransactionAnalytics {
  id                String    @id @default(cuid())
  paymentIntentId   String    @unique @map("payment_intent_id")

  // Behavioral Analytics
  timeOfDay         Int       @map("time_of_day") // Hour 0-23
  dayOfWeek         Int       @map("day_of_week") // 0-6 (Sunday=0)
  isWeekend         Boolean   @map("is_weekend")
  merchantType      String?   @map("merchant_type") // "restaurant", "retail", "transport", etc.
  location          String?   // Geographical location if available

  // Amount Analytics
  isRoundAmount     Boolean   @map("is_round_amount") // Is it 100, 500, 1000, etc.
  amountCategory    String    @map("amount_category") // "micro", "small", "medium", "large"
  frequencyScore    Float?    @map("frequency_score") // How often user pays this amount

  // Relationship Analytics
  isNewRecipient    Boolean   @map("is_new_recipient")
  recipientTrustScore Float?  @map("recipient_trust_score")
  relationshipType  String?   @map("relationship_type") // "personal", "merchant", "professional"

  // Pattern Analysis
  isRecurring       Boolean   @map("is_recurring")
  recurringPattern  String?   @map("recurring_pattern") // "daily", "weekly", "monthly"
  similarTransactionCount Int @map("similar_transaction_count")

  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  paymentIntent PaymentIntent @relation(fields: [paymentIntentId], references: [id], onDelete: Cascade)

  @@map("transaction_analytics")
}

// Indices for performance
model UserMonthlySpend {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  categoryId String   @map("category_id")
  year       Int
  month      Int
  amount     Decimal  @db.Decimal(12, 2)
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@unique([userId, categoryId, year, month])
  @@map("user_monthly_spends")
}

enum EscrowStatus {
  INITIATED
  PAID
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

model EscrowTransaction {
  id                    String        @id // Custom ID format: CAPN_ESCROW_timestamp_hash
  payerUpi             String        @map("payer_upi")
  recipientUpi         String        @map("recipient_upi")
  amount               Decimal       @db.Decimal(10, 2)
  note                 String
  status               EscrowStatus  @default(INITIATED)
  escrowCollectionId   String?       @map("escrow_collection_id") // Decentro collection transaction ID
  escrowPayoutId       String?       @map("escrow_payout_id")     // Decentro payout transaction ID
  collectionStatus     String?       @map("collection_status")    // Collection webhook status
  payoutStatus         String?       @map("payout_status")        // Payout webhook status
  retryCount           Int           @default(0) @map("retry_count")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @updatedAt @map("updated_at")

  @@index([payerUpi])
  @@index([recipientUpi])
  @@index([escrowCollectionId])
  @@index([escrowPayoutId])
  @@index([status])
  @@map("escrow_transactions")
}

model EscrowPayment {
  id                  String    @id @default(cuid())
  referenceId         String    @unique @map("reference_id")
  userId              String    @map("user_id")
  amount              Decimal   @db.Decimal(10, 2)
  recipientVpa        String    @map("recipient_vpa")
  recipientName       String?   @map("recipient_name")
  category            String?
  note                String?
  status              String    @default("collection_created")
  collectionTxnId     String    @map("collection_txn_id")
  payoutTxnId         String?   @map("payout_txn_id")
  payoutInitiatedAt   DateTime? @map("payout_initiated_at")
  completedAt         DateTime? @map("completed_at")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  @@index([referenceId])
  @@index([userId])
  @@index([status])
  @@map("escrow_payments")
}

// ================================
// BANKING-STANDARD MODELS
// ================================

// VPA Registry for centralized VPA management
model VpaRegistry {
  id                    String      @id @default(cuid())
  vpaAddress            String      @unique @map("vpa_address")
  userId                String      @map("user_id")
  extractedPhone        String?     @map("extracted_phone")
  bankName              String?     @map("bank_name")
  isVerified            Boolean     @default(false) @map("is_verified")
  isPrimary             Boolean     @default(false) @map("is_primary")
  riskLevel             RiskLevel   @default(LOW) @map("risk_level")
  verificationAttempts  Int         @default(0) @map("verification_attempts")
  lastVerifiedAt        DateTime?   @map("last_verified_at")
  categoryCatalogId     String?     @map("category_catalog_id")
  categoryConfidence    Float?      @map("category_confidence")
  votes                 Int         @default(1) // Phase 3: Vote count for category confidence
  lastLabeledAt         DateTime?   @map("last_labeled_at")
  lastUpdated           DateTime?   @map("last_updated") // Phase 3: Track when category was last updated
  createdAt             DateTime    @default(now()) @map("created_at")
  updatedAt             DateTime    @updatedAt @map("updated_at")

  // Relations
  user                  User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  categoryCatalog       CategoryCatalog? @relation(fields: [categoryCatalogId], references: [id])

  @@index([userId])
  @@index([riskLevel])
  @@index([categoryCatalogId])
  @@map("vpa_registry")
}

// Banking-Standard Payment Model
model BankingPayment {
  id                    String            @id @default(cuid())
  senderId              String            @map("sender_id")
  receiverId            String            @map("receiver_id")
  amount                Decimal           @db.Decimal(12, 2)
  currency              String            @default("INR")
  transferType          TransferType      @default(UPI) @map("transfer_type")
  paymentType           PaymentType       @default(P2P) @map("payment_type")

  // Collection details (money coming from sender)
  collectionId          String?           @unique @map("collection_id")
  collectionStatus      CollectionStatus  @default(INITIATED) @map("collection_status")
  collectionTxnNo       String?           @map("collection_txn_no")
  collectionRefNo       String?           @map("collection_ref_no")
  collectionCompletedAt DateTime?         @map("collection_completed_at")

  // Payout details (money going to receiver)
  payoutId              String?           @unique @map("payout_id")
  payoutStatus          PayoutStatus      @default(PENDING) @map("payout_status")
  payoutTxnNo           String?           @map("payout_txn_no")
  payoutRefNo           String?           @map("payout_ref_no")
  payoutCompletedAt     DateTime?         @map("payout_completed_at")

  // Overall status and metadata
  overallStatus         PaymentStatus     @default(CREATED) @map("overall_status")
  purpose               String?
  categoryId            String?           @map("category_id")
  feeAmount             Decimal?          @default(0.0) @db.Decimal(12, 2) @map("fee_amount")
  taxAmount             Decimal?          @default(0.0) @db.Decimal(12, 2) @map("tax_amount")

  // Refund management
  refundId              String?           @unique @map("refund_id")
  refundStatus          RefundStatus?     @map("refund_status")
  refundReason          String?           @map("refund_reason")

  // Risk and compliance
  riskScore             Decimal?          @default(0.0) @db.Decimal(3, 2) @map("risk_score")
  complianceCheckPassed Boolean           @default(true) @map("compliance_check_passed")
  fraudFlags            Json?             @map("fraud_flags")

  // Legacy compatibility
  legacyPaymentIntentId String?           @map("legacy_payment_intent_id")

  createdAt             DateTime          @default(now()) @map("created_at")
  updatedAt             DateTime          @updatedAt @map("updated_at")

  // Relations
  sender                User              @relation("PaymentSender", fields: [senderId], references: [id], onDelete: Restrict)
  receiver              User              @relation("PaymentReceiver", fields: [receiverId], references: [id], onDelete: Restrict)
  paymentIntent         PaymentIntent?    // Link back to payment intent
  collection            Collection?       @relation(fields: [collectionId], references: [id])
  payout                Payout?           @relation(fields: [payoutId], references: [id])
  refund                Refund?           @relation(fields: [refundId], references: [id])
  auditLogs             PaymentAuditLog[]
  statusHistory         PaymentStatusHistory[]

  @@index([senderId])
  @@index([receiverId])
  @@index([overallStatus])
  @@index([createdAt])
  @@index([collectionId])
  @@index([payoutId])
  @@map("banking_payments")
}

// Collection audit table
model Collection {
  id              String            @id @default(cuid())
  decentroTxnId   String            @unique @map("decentro_txn_id")
  amount          Decimal           @db.Decimal(12, 2)
  status          CollectionStatus  @default(INITIATED)
  webhookData     Json?             @map("webhook_data")
  retryCount      Int               @default(0) @map("retry_count")
  maxRetries      Int               @default(3) @map("max_retries")
  createdAt       DateTime          @default(now()) @map("created_at")
  updatedAt       DateTime          @updatedAt @map("updated_at")

  // Relations
  payment         BankingPayment?

  @@index([status])
  @@map("collections")
}

// Payout audit table
model Payout {
  id              String        @id @default(cuid())
  decentroTxnId   String        @unique @map("decentro_txn_id")
  amount          Decimal       @db.Decimal(12, 2)
  recipientVpa    String        @map("recipient_vpa")
  recipientName   String?       @map("recipient_name")
  status          PayoutStatus  @default(PENDING)
  webhookData     Json?         @map("webhook_data")
  retryCount      Int           @default(0) @map("retry_count")
  maxRetries      Int           @default(3) @map("max_retries")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  // Relations
  payment         BankingPayment?

  @@index([status])
  @@index([recipientVpa])
  @@map("payouts")
}

// Refund management
model Refund {
  id                  String        @id @default(cuid())
  originalPaymentId   String        @map("original_payment_id")
  refundTxnId         String?       @map("refund_txn_id")
  amount              Decimal       @db.Decimal(12, 2)
  status              RefundStatus  @default(INITIATED)
  reason              String
  adminNotes          String?       @map("admin_notes")
  retryCount          Int           @default(0) @map("retry_count")
  maxRetries          Int           @default(3) @map("max_retries")
  createdAt           DateTime      @default(now()) @map("created_at")
  updatedAt           DateTime      @updatedAt @map("updated_at")

  // Relations
  payment             BankingPayment?

  @@map("refunds")
}

// Comprehensive audit trail
model PaymentAuditLog {
  id                  String        @id @default(cuid())
  paymentId           String        @map("payment_id")
  action              AuditAction
  fromStatus          String?       @map("from_status")
  toStatus            String?       @map("to_status")
  metadata            Json?
  performedBy         String?       @map("performed_by")
  ipAddress           String?       @map("ip_address")
  userAgent           String?       @map("user_agent")
  deviceFingerprint   String?       @map("device_fingerprint")
  timestamp           DateTime      @default(now())

  // Relations
  payment             BankingPayment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([timestamp])
  @@index([action])
  @@map("payment_audit_logs")
}

// Payment Status History
model PaymentStatusHistory {
  id              String        @id @default(cuid())
  paymentId       String        @map("payment_id")
  status          String
  subStatus       String?       @map("sub_status")
  details         Json?
  systemNotes     String?       @map("system_notes")
  createdAt       DateTime      @default(now()) @map("created_at")

  // Relations
  payment         BankingPayment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([createdAt])
  @@map("payment_status_history")
}
